(function() {
  var Task, ctags, fs, handlerPath;

  Task = require('atom').Task;

  ctags = require('ctags');

  fs = require('fs-plus');

  handlerPath = require.resolve('./load-tags-handler');

  module.exports = {
    getTagsFile: function() {
      var directory, tagsFile;
      directory = atom.project.getDirectories()[0];
      if (directory == null) {
        return;
      }
      tagsFile = directory.resolve("tags");
      if (fs.isFileSync(tagsFile)) {
        return tagsFile;
      }
      tagsFile = directory.resolve("TAGS");
      if (fs.isFileSync(tagsFile)) {
        return tagsFile;
      }
      tagsFile = directory.resolve(".tags");
      if (fs.isFileSync(tagsFile)) {
        return tagsFile;
      }
      tagsFile = directory.resolve(".TAGS");
      if (fs.isFileSync(tagsFile)) {
        return tagsFile;
      }
    },
    find: function(editor, callback) {
      var range, symbol, tagsFile;
      if (editor.getLastCursor().getScopeDescriptor().getScopesArray().indexOf('source.ruby') !== -1) {
        range = editor.getLastCursor().getCurrentWordBufferRange({
          wordRegex: /[\w!?]*/g
        });
      } else {
        range = editor.getLastCursor().getCurrentWordBufferRange();
      }
      symbol = editor.getTextInRange(range);
      tagsFile = this.getTagsFile();
      if ((symbol != null ? symbol.length : void 0) > 0 && tagsFile) {
        return ctags.findTags(tagsFile, symbol, callback);
      } else {
        return process.nextTick(function() {
          return callback(null, []);
        });
      }
    },
    getAllTags: function(callback) {
      var projectPath, projectTags, task;
      projectTags = [];
      projectPath = atom.project.getPaths()[0];
      task = Task.once(handlerPath, projectPath, function() {
        return callback(projectTags);
      });
      task.on('tags', function(paths) {
        return projectTags.push.apply(projectTags, paths);
      });
      return task;
    }
  };

}).call(this);
